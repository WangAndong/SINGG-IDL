PRO ssoup_calprof_new, ll, band, photplam, ebvg, fprofs, fscalprof, ffcalprof, fscalprof0, ffcalprof0, $
                   fecntrat=fecntrat
  ;
  ; calibrate surface brightness profiles and their errors
  ; tabulate results into a single multiband output file.
  ;
  ;  ll         -> logical unit of log file
  ;  band       -> names of bands to process.  This should include
  ;                'R', 'HALPHA', 'NUV', 'FUV'
  ;  photplam   -> pivot wavelength of the bands
  ;  ebvg       -> Galactic (foreground) extinction
  ;  fprofs     -> corresponding profile file names
  ;                the original fits file names will be in the 
  ;                header section, and their headers in turn will
  ;                be read for additional parameters
  ;  fscalprof  -> name of file for output calibrated surface 
  ;                brightness profiles and errors.  
  ;  ffcalprof  -> name of file for output calibrated enclosed flux 
  ;                and error profiles
  ;  fscalprof0 -> name of file output dust corrected surface 
  ;                brightness and error profiles
  ;  ffcalprof0 -> name of file for output dust corrected enclosed 
  ;                flux and error profiles.
  ;  fecntrat   -> If set the the fractional error in the continuum
  ;                scaling ratio.  Otherwise the error in the scaling 
  ;                ratio is taken from the net Halpha image fits 
  ;                header.
  ;
  ; G. Meurer (ICRAR/UWA) 6/2010
  ; G. Meurer (ICRAR/UWA) 4/2011: tidy code fix so it works on 
  ;                               multiple galaxies in the field
  ;
  ; setup stuff
  bname   = ['R', 'HALPHA', 'NUV', 'FUV']
  fmto    = '(f7.2,f8.3,f6.3,f9.3,f6.3,f6.3,f6.3,f8.3,f6.3,f8.3,f6.3,f8.3,f6.3,f8.3,f6.3,f7.3,f6.3,f7.3,f6.3)'
  hlines1 = '# Surface quantities (in annuli)'
  hlines2 = '#  sma   mu_R   err     lSHa   esky  ecnt  etot   mu_nuv err    mu_fuv err    C(f-n) err    C(n-R) err    lHa/R err    lHa/f err  '
  hlines3 = '# Surface quantities, dust corrected (in annuli)'
  hlinef1 = '# Integral quantities (in apertures)'
  hlinef2 = '#  sma   mag_R  err     lFHa   esky  ecnt  etot  mag_nuv err   mag_fuv err    C(f-n) err    C(n-R) err    lHa/R err    lHa/f err  '
  hlinef3 = '# Integral quantities, dust corrected (in apertures)'
  ;snlimit = 3.0
  snlimit = 2.0  ; GRM 4/2011 : go out further
  pixsize = 1.0
  mflag   =  99.999  ; magnitude flag value
  emflag  =   9.999  ; error mag flag
  lflag   = -99.999  ; log flux flux value
  elflag  =   9.999  ; error log flag
  prog    = 'SSOUP_CALPROF_NEW: '
  ;
  nb      = n_elements(bname)
  ;
  plog,ll,prog,'----------------- starting '+prog+'----------------------'
  ;
  ; convert S/N limit to err limits in mag and dex
  edlim   = alog10(1.0+1.0/snlimit)    ; dex
  emlim   = 2.5*edlim                  ; mag
  ;
  ; read one header just to get number of galaxies
  pfplt_rdhdr, fprofs[0], pixsize, filename, funits, fscale, fluxcal, $
               proftype, numgals, galindex, xcenter, ycenter, $
               axerat, posang, posangwc, skylev, skysigpx, skysigbx, $
               rads, radf, radc, fluxs, fluxf, fluxt, flsigskys, flsigskyf, flsigskyt, $
               flsigcnts, flsigcntf, flsigcntt, ref, ret, $
               resigskyf, resigskyt, resigcntf, resigcntt, sef, set, $
               lstart, lend, isoflag, netflag, /silent
  ngal     = numgals
  arat     = axerat
  plog,ll,prog,'number of galaxies in profile files = '+numstr(ngal)
  ;
  ; work out bname <-> band correspondence 
  plog,ll,prog,'working out band name correspondence'
  p0       = where(band EQ bname[0],np0)
  p1       = where(band EQ bname[1],np1)
  p2       = where(band EQ bname[2],np2)
  p3       = where(band EQ bname[3],np3)
  pb       = [p0, p1, p2, p3]
  ;
  ; get deredden parameters
  dredf    = make_array(nb, /float, value=1.0)
  IF ebvg GT 0 THEN ccm_unred, photplam, dredf, ebvg[0]
  plog,ll,prog,'will de-redden fluxes for foreground dust using the following band | wl | factor sets'
  FOR ii = 0, nb-1 DO plog,ll,prog,'   '+ljust(band[ii],6)+' | '+numstr(photplam[ii])+' | '+numstr(dredf[ii])
  ;
  phpl2    = photplam
  pp       = where(band EQ 'HALPHA',npp)
  IF npp GE 1 THEN phpl2[pp] = 6563.8
  acalzlaw = make_array(nb, /float, value=1.0)
  calz_unred, phpl2, acalzlaw, 1.0
  acalzlaw = 2.5*alog10(acalzlaw)
  IF npp GE 1 THEN acalzlaw[pp] = acalzlaw[pp]/0.45   ; correct for emission lines
  plog,ll,prog,'will de-redden fluxes for internal dust by the following law (Calzetti): band | wl | mag/E(B-V)'
  FOR ii = 0, nb-1 DO plog,ll,prog,'   '+ljust(band[ii],6)+' | '+numstr(phpl2[ii])+' | '+numstr(acalzlaw[ii])
  ;
  ; arrays for different galaxies will be concatenated
  ; work out start and stop elements
  nring    = lend - lstart + 1
  pt0      = make_array(ngal, /long, value=0l)
  FOR ii = 1, ngal-1 DO pt0[ii] = pt0[ii-1]+nring[ii-1]  ; start position of array for this galaxy
  pt1      = pt0 + nring - 1l                            ; end position of header
  nrtot    = total(nring)
  plog,ll,prog,'total number of rings = '+numstr(nrtot)
  FOR ii = 0, ngal-1 DO plog,ll,prog,'Galaxy #'+numstr(ii)+' number of rings = '+numstr(nring[ii])
  ;
  ; make arrays to store stuff
  ; in the following quantities starting (or containing):
  ; "sb" - linear surface brightness (per arcsec^2)
  ; "fb" - linear flux (integerated within aperture)
  ; "sm" - logarithmic surface brightness (mag or log per arcsec^2)
  ; "fm" - logarithmic flux 
  filnam   = make_array(nb, /string, value='')
  rad      = make_array(nrtot)
  sbprof   = make_array(nrtot,nb)   ; surface brightnes linear units all bands
  esbproft = make_array(nrtot,nb)   ; total error in surface brightness linear units all bands
  esbprofc = make_array(nrtot)      ; Halpha continuum subtraction error linear surf bright
  esbprofs = make_array(nrtot)      ; Halpha sky + photon error linear surf bright
  smprof   = make_array(nrtot,nb)   ; surface brightnes log units all bands
  esmproft = make_array(nrtot,nb)   ; total error in surface brightness from sky all bands
  esmprofc = make_array(nrtot)      ; Halpha continuum subtraction error log surf bright
  esmprofs = make_array(nrtot)      ; Halpha sky + photon error log surf bright
  fbprof   = make_array(nrtot,nb)   ; flux linear units all bands
  efbproft = make_array(nrtot,nb)   ; total error in flux linear units 
  efbprofc = make_array(nrtot)      ; Halpha continuum subtraction error linear flux
  efbprofs = make_array(nrtot)      ; Halpha sky+photon error linear flux
  fmprof   = make_array(nrtot,nb)   ; log flux all bands
  efmproft = make_array(nrtot,nb)   ; total error in log flux 
  efmprofc = make_array(nrtot)      ; Halpha continuum subtraction error log flux
  efmprofs = make_array(nrtot)      ; Halpha sky + photon error surf bright
  mag0     = make_array(nb, /float, value=0.0)   ; magnitude scale zeropoint
  phfl     = make_array(nb, /float, value=0.0)   ; photflam (continuum) or photflux (Halpha)
  ;
  ; loop through bands
  FOR ii = 0, nb-1 DO BEGIN 
     ;
     ; pointer to position in db arrays
     pp     = pb[ii]
     ;
     ; read header of file, the main important info is the filename
     plog,ll,prog,'reading in header of file : '+fprofs[pp]
     pixsize = 0.0
     pfplt_rdhdr, fprofs[pp], pixsize, filename, funits, fscale, fluxcal, $
                  proftype, numgals, galindex, xcenter, ycenter, $
                  axerat, posang, posangwc, skylev, skysigpx, skysigbx, $
                  rads, radf, radc, fluxs, fluxf, fluxt, flsigskys, flsigskyf, flsigskyt, $
                  flsigcnts, flsigcntf, flsigcntt, ref, ret, $
                  resigskyf, resigskyt, resigcntf, resigcntt, sef, set, $
                  lstart, lend, isoflag, netflag, /silent
     filnam[ii] = filename
     pixarea    = pixsize*pixsize
     ;
     ; Get stuff from fits header
     plog,ll,prog,'reading in header quantities from fits file: '+filename
     fits_read, filename, im, hd, /header_only
     exptime    = sxpar(hd, 'EXPTIME', count=count)
     IF count NE 1 THEN stop, '**** should be one & only one EXPTIME in header, found='+numstr(count)
     eslev      = sxpar(hd, 'SKYSIGBX', count=count)
     IF count NE 1 THEN stop, '**** should be one & only one SKYSIGBX in header, found='+numstr(count)
     plog,ll,prog,'    SKYSIGBX = '+numstr(eslev)
     skylev     = sxpar(hd, 'SKYLEV', count=count)
     IF count NE 1 THEN stop, '**** should be one & only one SKYLEV in header, found='+numstr(count)
     IF bname[ii] EQ 'HALPHA' THEN BEGIN 
        ;
        ; get PHOTFLUX, CNTRAT1, ECNTRAT2
        netflag = 1b
        phfl[ii] = sxpar(hd, 'PHOTFLUX', count=count)
        IF count NE 1 THEN stop, '**** should be one and only one PHOTFLUX in header, found'+numstr(count)
        mag0[ii] = alog10(phfl[ii])
        plog,ll,prog,'    PHOTFLUX = '+numstr(mag0[ii])
        crat     = sxpar(hd, 'CNTRAT1', count=count)
        IF count NE 1 THEN stop, '**** should be one and only one CNTRAT1 in header, found'+numstr(count)
        plog,ll,prog,'    CNTRAT1 = '+numstr(crat)
        IF keyword_set(fecntrat) THEN BEGIN 
           ecrat = fecntrat*crat
           plog,ll,prog,'    ECNTRAT2 = '+numstr(ecrat)+'  ( = default_ratio * CNTRAT1)'
        ENDIF ELSE BEGIN 
           ecrat = sxpar(hd, 'ECNTRAT2', count=count)
           IF count NE 1 THEN stop, '**** should be one and only one ECNTRAT2 in header, found'+numstr(count)
           plog,ll,prog,'    ECNTRAT2 = '+numstr(ecrat)
        ENDELSE 
     ENDIF ELSE BEGIN 
        ;
        ; get MAGZPT1, PHOTFLAM
        netflag  = 0b
        mag0[ii] = sxpar(hd, 'MAGZPT1', count=count)
        IF count NE 1 THEN stop, '**** should be one and only one MAGZPT1 in header, found'+numstr(count)
        plog,ll,prog,'    MAGZPT1 = '+numstr(mag0[ii])
        phfl[ii] = sxpar(hd, 'PHOTFLAM', count=count)
        IF count NE 1 THEN stop, '**** should be one and only one PHOTFLAM in header, found'+numstr(count)
        plog,ll,prog,'    PHOTFLAM = '+numstr(phfl[ii])
     ENDELSE 
     ;
     ; read profiles and store
     FOR jj = 0, ngal-1 DO BEGIN 
        ptt0     = pt0[jj]    ; this saves me some typing
        ptt1     = pt1[jj]    ; this saves me some typing
        ;
        plog,ll,prog,'reading profile for galaxy #'+numstr(jj+1)
        ;pfplt_extractprof, fprofs[pp], netflag, sma, fint, dfint, ngood, nbad, sb, esb, $
        ;                   dfraw, egintsk, efintcn, lstart=lstart[jj], lend=lend[jj]
        pfplt_extractprof, fprofs[pp], 0b, sma, fint, dfint, ngood, nbad, sb, esb, $
                           dfraw, egintsk, efintcn, lstart=lstart[jj], lend=lend[jj]
        ;
        ; derive Poissonian error contribution
        nap      = n_elements(sma)                    ; number of apertures
        k1       = 1+indgen(nap-1)                   ; index for outer radius of annuli 
        k0       = k1 - 1                            ; index for inner radius of annuli
        sma0     = make_array(nap,/float,value=0.0)  ; put interior radius of annulus here
        sma0[k1] = sma[k0]                           ; sets all inner radii except for 1st annulus where inner rad = 0.0 in prev line
        npixap   = !pi*sma^2/axerat[jj]              ; ideal number of pixels in ap
        npixan   = !pi*(sma^2 - sma0^2)/axerat[jj]   ; ideal number of pixels in an 
        ngoodt   = total(ngood,/cumulative)          ; total good pixels in apertures
        frawan   = ngood*sb                          ; flux from pixels centered in annulus, doesn't include bad pixels
        frawap   = total(frawan,/cumulative)         ; total flux not corrected for partial or bad pixels
        IF band[ii] NE 'HALPHA' THEN BEGIN 
           ephotsb = sqrt((sb + skylev)/(exptime*ngood))  ; photon error per pixel
           ephotfb = (fint/frawap)*sqrt((frawap+ngoodt*skylev)/exptime)   ; photon error in ap 
        ENDIF ELSE BEGIN 
           ephotsb = 0.0*sb       ; **** have not yet implemented photon stats uncertainty for Halpha
           ephotfb = 0.0*fint
        ENDELSE 
        ;
        ; convert to final quantities and store  
        plog,ll,prog,'inclination correct and derive fractional sky errors for galaxy #'+numstr(jj+1)
        IF ii EQ 0 THEN rad[ptt0:ptt1] = sma*pixsize
        sbprof[ptt0:ptt1,ii]   = sb/(axerat[jj]*pixarea)  ; correct to SB per area, and correct to face-on
        fbprof[ptt0:ptt1,ii]   = fint/axerat[jj]          ; correct to face-on
        esbproft[ptt0:ptt1,ii] = sqrt(eslev^2+ephotsb^2)       ; total error = sky+photon
        efbproft[ptt0:ptt1,ii] = sqrt(npixap*eslev+ephotfb^2)  ; total error = sky+photon
     ENDFOR 
  ENDFOR
  ;
  ; some pointers to be sure
  im        = where(bname NE 'HALPHA', nim)   ; points to continuum bands, **** is this needed?
  ih        = where(bname EQ 'HALPHA', nih)
  ir        = where(bname EQ 'R', nir)
  ih        = ih[0]
  ir        = ir[0]
  ;
  ; derive continuum subtraction and total fractional errors for Halpha
  plog,ll,prog,'calculating HALPHA continuum subtraction, sky+photon and total errors '
  esbprofc[ptt0:ptt1]        = ecrat*sbprof[ptt0:ptt1,ir]                       ; continuum subtraction error
  efbprofc[ptt0:ptt1]        = ecrat*fbprof[ptt0:ptt1,ir]                       ; continuum subtraction error
  esbprofs[ptt0:ptt1]        = esbproft[ptt0:ptt1,ih]                           ; assign Halpha sky error to prev calculated total error
  efbprofs[ptt0:ptt1]        = efbproft[ptt0:ptt1,ih]                           ; assign Halpha sky error to prev calculated total error
  esbproft[ptt0:ptt1,ih[0]]  = sqrt(esbprofc[ptt0:ptt1]^2 + esbprofs[ptt0:ptt1]^2)  ; recalculate total error
  esbproft[ptt0:ptt1,ih[0]]  = sqrt(efbprofc[ptt0:ptt1]^2 + efbprofs[ptt0:ptt1]^2)  ; recalculate total error
  ;
  ; flux cal, and correct for foreground dust
  ; convert errors to magnitudes and logs as needed
  plog,ll,prog,'flux calibrating and foreground dust correct all bands'
  ;
  ; loop through bands
  FOR ii = 0, nb-1 DO BEGIN 
     ;
     ; calibrate logarithmic or mag scale surface brightness profiles
     kk = where(sbprof[*,ii] GT 0.0, nkk)     ; will have valid logs
     IF nkk GT 0 THEN BEGIN 
        IF ii NE ih THEN BEGIN 
           smprof[kk,ii]   = mag0[ii] - 2.5*alog10(dredf[ii]*sbprof[kk,ii]) 
           esmproft[kk,ii] = 2.5*alog10(1.0+esbproft[kk,ii]/sbprof[kk,ii]) 
        ENDIF ELSE BEGIN 
           smprof[kk,ii]   = mag0[ii] + alog10(dredf[ii]*sbprof[kk,ii])
           esmproft[kk,ii] = alog10(1.0+esbproft[kk,ii]/sbprof[kk,ii])
           esmprofc[kk]    = alog10(1.0+esbprofc[kk]/sbprof[kk,ii])
           esmprofs[kk]    = alog10(1.0+esbprofs[kk]/sbprof[kk,ii])
        ENDELSE 
     ENDIF
     kk = where(sbprof[*,ii] LE 0.0, nkk)     ; will have invalid logs, flag these
     IF nkk GT 0 THEN BEGIN 
        ; set appropriate flags
        IF ii NE ih THEN BEGIN 
           smprof[kk,ii]   = mflag
           esmproft[kk,ii] = emflag
        ENDIF ELSE BEGIN 
           smprof[kk,ii]   = lflag 
           esmproft[kk,ii] = elflag
           esmprofc[kk]    = elflag
           esmprofs[kk]    = elflag
        ENDELSE 
     ENDIF
     ;
     ; calibrate logarithmic or mag scale enclosed flux profiles
     kk = where(fbprof[*,ii] GT 0.0, nkk)     ; will have valid logs
     IF nkk GT 0 THEN BEGIN 
        IF ii NE ih THEN BEGIN 
           fmprof[kk,ii]   = mag0[ii] - 2.5*alog10(dredf[ii]*fbprof[kk,ii]) 
           efmproft[kk,ii] = 2.5*alog10(1.0+efbproft[kk,ii]/fbprof[kk,ii]) 
        ENDIF ELSE BEGIN 
           fmprof[kk,ii]   = mag0[ii] + alog10(dredf[ii]*fbprof[kk,ii])
           efmproft[kk,ii] = alog10(1.0+efbproft[kk,ii]/fbprof[kk,ii])
           efmprofc[kk]    = alog10(1.0+efbprofc[kk]/fbprof[kk,ii])
           efmprofs[kk]    = alog10(1.0+efbprofs[kk]/fbprof[kk,ii])
        ENDELSE 
     ENDIF
     kk = where(fbprof[*,ii] LE 0.0, nkk)     ; will have invalid logs, flag these
     IF nkk GT 0 THEN BEGIN 
        ; set appropriate flags
        IF ii NE ih THEN BEGIN 
           fmprof[kk,ii]   = mflag
           efmproft[kk,ii] = emflag
        ENDIF ELSE BEGIN 
           fmprof[kk,ii]   = lflag 
           efmproft[kk,ii] = elflag
           efmprofc[kk]    = elflag
           efmprofs[kk]    = elflag
        ENDELSE 
     ENDIF
     ;
     ; now calibrate linear surface brightness and enclosed fluxes,
     ; this requires rewriting flux (& sb) arrays which are in
     ; count/s (/area) to erg/cm^2/s (/area) and rewriting the
     ; relevant error arrays which are cuurrently in uncalibrated
     ; countrate
     sbprof[*,ii]   = dredf[ii]*phfl[ii]*sbprof[*,ii]
     esbproft[*,ii] = dredf[ii]*phfl[ii]*esbproft[*,ii]
     fbprof[*,ii]   = dredf[ii]*phfl[ii]*fbprof[*,ii]
     efbproft[*,ii] = dredf[ii]*phfl[ii]*efbproft[*,ii]
     IF ii EQ ih THEN BEGIN 
        esbprofc = dredf[ii]*phfl[ii]*esbprofc
        esbprofs = dredf[ii]*phfl[ii]*esbprofs
        efbprofc = dredf[ii]*phfl[ii]*esbprofc
        efbprofs = dredf[ii]*phfl[ii]*esbprofs
     ENDIF 
  ENDFOR 
  ;
  ; calculate colors and errors
  ; we do this by calling ssoup_cp_ccolours because there are 
  ; places we do this.
  ssoup_cp_ccolours, ll, bname, mag0, phfl, smprof, esmproft, smcfn, esmcfnt, smcnr, esmcnrt, slewr, eslewrt, slewf, eslewft
  ssoup_cp_ccolours, ll, bname, mag0, phfl, fmprof, efmproft, fmcfn, efmcfnt, fmcnr, efmcnrt, flewr, eflewrt, flewf, eflewft
  ;
  ; get sma for annuli
  plog,ll,prog,'calculating annuli radii'
  radan  = 0.0*rad
  FOR jj = 0, ngal-1 DO BEGIN 
     ptt0      = pt0[jj]    ; this saves me some typing
     ptt1      = pt1[jj]    ; this saves me some typing
     nap       = ptt1-ptt0+1l
     sma_ap    = rad[ptt0:ptt1]
     sma_an    = make_array(nap, /float, value=0.0)
     sma_an[0] = sma_ap[0]/sqrt(2)
     IF nap GT 1 THEN BEGIN 
        kk0         = lindgen(nap-1)
        kk1         = kk0+1l
        sma_an[kk1] = sqrt((sma_ap[kk0]^2+sma_ap[kk1]^2)/2.)
     ENDIF 
     radan[ptt0:ptt1] = sma_an
  ENDFOR 
  ;
  ; derive maximum good radius
  plog,ll,prog,'deriving maximum radii'
  kssnlim  = make_array(ngal, nb, /long, value=0l)  ; limit for surface brightness
  kfsnlim  = make_array(ngal, nb, /long, value=0l)  ; limit for total flux
  kssnlimg = make_array(ngal, /long, value=0l)
  kfsnlimg = make_array(ngal, /long, value=0l)
  ;
  ; loop through galaxies
  FOR jj = 0, ngal-1 DO BEGIN 
     ptt0     = pt0[jj]    ; this saves me some typing
     ptt1     = pt1[jj]    ; this saves me some typing
     ;
     ; loop through bands
     FOR ii = 0, nb-1 DO BEGIN 
        efproft_ = efmproft[ptt0:ptt1,ii]
        esproft_ = esmproft[ptt0:ptt1,ii]
        IF bname[ii] EQ 'HALPHA' THEN BEGIN 
           kk       = where(efproft_ LE edlim AND efproft_ NE elflag, nkk)
           IF nkk GT 0 THEN kfsnlim[jj,ii] = max(kk) ELSE kfsnlim[jj,ii] = nring[jj]-1l
           kk       = where(esproft_ LE edlim AND esproft_ NE elflag, nkk)
           IF nkk GT 0 THEN kssnlim[jj,ii] = max(kk) ELSE kssnlim[jj,ii] = nring[jj]-1l
        ENDIF ELSE BEGIN 
           kk       = where(efproft_ LE emlim AND efproft_ NE emflag, nkk)
           IF nkk GT 0 THEN kfsnlim[jj,ii] = max(kk) ELSE kfsnlim[jj,ii] = nring[jj]-1l
           kk       = where(esproft_ LE emlim AND esproft_ NE emflag, nkk)
           IF nkk GT 0 THEN kssnlim[jj,ii] = max(kk) ELSE kssnlim[jj,ii] = nring[jj]-1l
        ENDELSE 
        ;print,nring[jj],kfsnlim[jj,0:3],kssnlim[jj,0:3]
     ENDFOR 
     kfsnlimg[jj] = max(kfsnlim[jj,*])
     kssnlimg[jj] = max(kssnlim[jj,*])
     sma_         = rad[ptt0:ptt1]
     sma_an_      = radan[ptt0:ptt1]
     plog,ll,prog,'Galaxy #'+numstr(jj+1)+' flux max(index) = '+numstr(kfsnlimg[jj])+' max(sma_ap) = '+numstr(sma_[kfsnlimg])
     plog,ll,prog,'         '+          ' sb max(index)   = '+numstr(kssnlimg[jj])+' max(sma_an) = '+numstr(sma_an_[kssnlimg])
  ENDFOR 
  ;
  ; open output file
  plog,ll,prog,'writing calibrated surface brightnesses and colors file '+fscalprof
  openw, lu, fscalprof, /get_lun
  ;
  ; write header lines
  printf,-1,hlines1
  printf,-1,hlines2
  printf,lu,hlines1
  printf,lu,hlines2
  ;
  ; write rest of output file
  FOR jj = 0, ngal-1 DO BEGIN 
     ptt0     = pt0[jj]    ; this saves me some typing
     ptt1     = pt1[jj]    ; this saves me some typing
     ;
     IF ngal GT 0 THEN BEGIN 
        printf,-1,'# galaxy index #'+numstr(jj+1)
        printf,lu,'# galaxy index #'+numstr(jj+1)
     ENDIF 
     FOR ii = ptt0, ptt0+kssnlimg[jj] DO BEGIN 
        printf,-1,radan[ii],smprof[ii,0],esmproft[ii,0],smprof[ii,1],esmprofs[ii],$
               esmprofc[ii],esmproft[ii],smprof[ii,2],esmproft[ii,2],smprof[ii,3],$
               esmproft[ii,3],smcfn[ii],esmcfnt[ii],smcnr[ii],esmcnrt[ii],$
               slewr[ii],eslewrt[ii],slewf[ii],eslewft[ii],format=fmto
        printf,lu,radan[ii],smprof[ii,0],esmproft[ii,0],smprof[ii,1],esmprofs[ii],$
               esmprofc[ii],esmproft[ii],smprof[ii,2],esmproft[ii,2],smprof[ii,3],$
               esmproft[ii,3],smcfn[ii],esmcfnt[ii],smcnr[ii],esmcnrt[ii],$
               slewr[ii],eslewrt[ii],slewf[ii],eslewft[ii],format=fmto
     ENDFOR 
  ENDFOR 
  free_lun, lu
  ;
  ; now work on calibrate enclosed flux/ color proffiles
  openw, lu, ffcalprof, /get_lun
  plog,ll,prog,'writing calibrated surface brightnesses and colors file '+fscalprof
  printf,-1,hlinef1
  printf,-1,hlinef2
  printf,lu,hlinef1
  printf,lu,hlinef2
  ;
  ; write rest of output file
  FOR jj = 0, ngal-1 DO BEGIN 
     ptt0     = pt0[jj]    ; this saves me some typing
     ptt1     = pt1[jj]    ; this saves me some typing
     IF ngal GT 0 THEN BEGIN 
        printf,-1,'# galaxy index #'+numstr(jj+1)
        printf,lu,'# galaxy index #'+numstr(jj+1)
     ENDIF 
     FOR ii = ptt0, ptt0+kfsnlimg[jj] DO BEGIN 
        printf,-1,rad[ii],fmprof[ii,0],efmproft[ii,0],fmprof[ii,1],efmproft[ii,1],$
               efmprofc[ii],efmprofc[ii],fmprof[ii,2],efmproft[ii,2],fmprof[ii,3],$
               efmproft[ii,3],fmcfn[ii],efmcfnt[ii],fmcnr[ii],efmcnrt[ii],$
               flewr[ii],eflewrt[ii],flewf[ii],eflewft[ii],format=fmto
        printf,-1,rad[ii],fmprof[ii,0],efmproft[ii,0],fmprof[ii,1],efmproft[ii,1],$
               efmprofc[ii],efmprofs[ii],fmprof[ii,2],efmproft[ii,2],fmprof[ii,3],$
               efmproft[ii,3],fmcfn[ii],efmcfnt[ii],fmcnr[ii],efmcnrt[ii],$
               flewr[ii],eflewrt[ii],flewf[ii],eflewft[ii],format=fmto
     ENDFOR 
  ENDFOR 
  free_lun, lu
  ;
  ; derive dust corrected colors and flux ratios
  ;
  ; make arrays for reddening corrected quantities
  ; for now using same nrtot as for un-corrected quantities.  
  ; some compaction is possible, in some cases
  sbprof0   = make_array(nrtot,nb)   ; surface brightnes linear units all bands, corrected for internal dust
  smprof0   = make_array(nrtot,nb)   ; surface brightnes log units all bands, corrected for internal dust
  fbprof0   = make_array(nrtot,nb)   ; flux linear units all bands, corrected for internal dust
  fmprof0   = make_array(nrtot,nb)   ; log flux all bands, corrected for internal dust
  esbproft0 = make_array(nrtot,nb)
  efbproft0 = make_array(nrtot,nb)
  esmproft0 = make_array(nrtot,nb)
  efmproft0 = make_array(nrtot,nb)
  ;
  ; calculate colors and errors
  plog,ll,prog,'calculating dust corrected colors and errors'
  ;
  ; derive internal extinction vector, using IRX-beta fit of Boissier
  ; et al. (2007, ApJS, 173, 524-537; see pg528)
  ca   =  0.570
  cb   =  0.671
  cc   =  3.220
  lirx =  alog10(10.0^(ca + cb*smcfn)-cc)
  afuv = -0.0333*lirx^3+0.3522*lirx^2+1.1960*lirx+0.4967  ; A(FUV) as a function of radius
  pf   = where(band EQ 'FUV', npf)
  IF npp NE 1 THEN stop, 'there should be one and only one FUV band'
  ;
  ; derive dust corrected maximum good radius
  plog,ll,prog,'deriving dust corrected maximum radii'
  kssnlim0  = make_array(ngal, nb, /long, value=0l)  ; limit for surface brightness
  kfsnlim0  = make_array(ngal, nb, /long, value=0l)  ; limit for total flux
  kssnlimg0 = make_array(ngal, /long, value=0l)
  kfsnlimg0 = make_array(ngal, /long, value=0l)
  ;
  ; loop through galaxies
  FOR jj = 0, ngal-1 DO BEGIN 
     ptt0     = pt0[jj]    ; this saves me some typing
     ptt1     = pt1[jj]    ; this saves me some typing
     ;
     ; pointers to how far out the reddening correction goes
     ksnf = min([kssnlim[jj,p2],kssnlim[jj,p3]])  
     kfnf = min([kssnlim[jj,p2],kssnlim[jj,p3]])
     ;
     ; loop through bands
     FOR ii = 0, nb-1 DO BEGIN 
        ;
        ; new limits is the minimum of the limit for the S/N of the band
        ; and the limit of the reddening correction
        kssnlim0[jj,ii] = min([kssnlim[jj,ii],ksnf])
        kfsnlim0[jj,ii] = min([kfsnlim[jj,ii],kfnf])
     ENDFOR 
     kfsnlimg0[jj] = max(kfsnlim0[jj,*])
     kssnlimg0[jj] = max(kssnlim0[jj,*])
     sma_          = rad[ptt0:ptt1]
     sma_an_       = radan[ptt0:ptt1]
     plog,ll,prog,'Galaxy #'+numstr(jj+1)+' flux max(index) = '+numstr(kfsnlimg[jj])+' max(sma_ap) = '+numstr(sma_[kfsnlimg])
     plog,ll,prog,'         '+          ' sb max(index)   = '+numstr(kssnlimg[jj])+' max(sma_an) = '+numstr(sma_an_[kssnlimg])
  ENDFOR 
  ;
  ; loop through bands and dust correct surface fluxes and magnitudes quantities
  plog,ll,prog,'Calculating internal dust corrected surface-brightnesses...'
  mg0   = 0.0*mg  ; initialize dust corrected magnitudes and fluxes
  emg0  = emg     ; should 
  FOR ii = 0, nb-1 DO BEGIN
     afact       = acalzlaw[ii]/acalzlaw[pf]      ; factor to multiply A_FUV by to get A_band
     afact       = afact[0]                       ; have to convert this to a scalar...
     aband       = -1.0*afuv*afact                ; magnitude correction this should now be an array, since afuv is an array
     sbfact      = 10.0^(-0.4*aband)
     flgtest     = mflag
     eflgtest    = emflag
     IF band[ii] EQ 'HALPHA' THEN  BEGIN 
        aband    = -0.4*aband                     ; convert to dex for Halpha
        sbfact   = 10.0^(aband)
        flgtest  = lflag
        eflgtest = elflag
     ENDIF 
     ;
     ; find good elements (kg) and elements to flag (kb)
     kg          = where(mg[*,ii] NE flgtest AND emg[*,ii] NE eflgtest, nkg)
     kb          = where(mg[*,ii] EQ flgtest OR emg[*,ii] EQ eflgtest, nkg)
     IF nkg GT 0 THEN BEGIN 
        mg0[kg,ii]       = mg[kg] + aband
        esbproft0[kg,ii] = sbfact[kg]*esbproft[kg,ii]
        IF band[ii] EQ 'HALPHA' THEN  BEGIN 
           esbprofc0[kg] = sbfact[kg]*esbprofc[kg]
           esbprofs0[kg] = sbfact[kg]*esbprofs[kg]
        ENDIF 
        smprof0[kg,ii]   = sbprof[kg,ii] + aband[kg]
        esmproft0[kg,ii] = esbproft[kg,ii]
        IF band[ii] EQ 'HALPHA' THEN  BEGIN 
           esbprofc0[kg] = esbprofc[kg]
           esbprofs0[kg] = esbprofs[kg]
        ENDIF 
     ENDIF 
     IF nkb GT 0 THEN BEGIN 
        ;
        ; copy, don't alter the bad linear surf bright and errors
        ; so that integration will work
        sbprof0[kb,ii]   = sbprof[kb,ii]
        esbproft0[kb,ii] = esbproft[kb,ii]
        IF band[ii] EQ 'HALPHA' THEN  BEGIN 
           esbprofc0[kg] = esbprofc[kg]
           esbprofs0[kg] = esbprofs[kg]
        ENDIF 
        ;
        ; but do flag the log quantities
        smprof0[kb,ii]   = flgtest
        esmproft0[kb,ii] = eflgtest
        IF band[ii] EQ 'HALPHA' THEN  BEGIN 
           esmprofc0[kg] = eflgtest
           esmprofs0[kg] = eflgtest
        ENDIF 
     ENDIF 
  ENDFOR 
  ;
  ; calculate surface colours
  ssoup_cp_ccolours, ll, bname, mag0, phfl, smprof0, esmproft0, smcfn0, esmcfn0, smcnr0, esmcnr0, slewr0, eslewr0, slewf0, eslewf0
  ;
  ; open output file - surface quantities, dust corrected
  plog,ll,prog,'wrting dust correceted surface brightness profile file: '+fscalprof0
  openw, lu, fscalprof0, /get_lun
  ; 
  ; write header lines
  printf,-1,hlines3
  printf,-1,hlines2
  printf,lu,hlines3
  printf,lu,hlines2
  ;
  ; write rest of output file
  FOR jj = 0, ngal-1 DO BEGIN 
     ptt0     = pt0[jj]    ; this saves me some typing
     ptt1     = pt1[jj]    ; this saves me some typing
     ;
     IF ngal GT 0 THEN BEGIN 
        printf,-1,'# galaxy index #'+numstr(jj+1)
        printf,lu,'# galaxy index #'+numstr(jj+1)
     ENDIF 
     FOR ii = ptt0, ptt0+kssnlimg0[jj] DO BEGIN 
        printf,-1,radan[ii],smprof0[ii,0],esmproft0[ii,0],smprof0[ii,1],esmproft0[ii,1],$
               esmprofc0[ii],esmprofs0[ii],smprof0[ii,2],esmproft0[ii,2],smprof0[ii,3],$
               esmproft0[ii,3],smcfn0[ii],esmcfn0[ii],smcnr0[ii],esmcnr0[ii],$
               slewr0[ii],eslewr0[ii],slewf0[ii],eslewf0[ii],format=fmto
        printf,lu,radan[ii],smprof0[ii,0],esmproft0[ii,0],smprof0[ii,1],esmproft0[ii,1],$
               esmprofc0[ii],esmprofs0[ii],smprof0[ii,2],esmproft0[ii,2],smprof0[ii,3],$
               esmproft0[ii,3],smcfn0[ii],esmcfn0[ii],smcnr0[ii],esmcnr0[ii],$
               slewr0[ii],eslewr0[ii],slewf0[ii],eslewf0[ii],format=fmto
     ENDFOR 
  ENDFOR 
  free_lun, lu
  ;
  ; reintegrate linear surface brightnesses to get fluxes
  plog,ll,prog,'integrating dust corrected surface brightness profiles to get dust corrected enclosed fluxes '
  FOR jj = 0, ngal-1 DO BEGIN 
     ptt0     = pt0[jj]    ; this saves me some typing
     ptt1     = pt1[jj]    ; this saves me some typing
     nap      = ptt1 - ptt0 + 1
     rout     = rad[ptt0:ptt1]
     rin      = [0.0,rad[ptt0:ptt1-1]]
     anarea   = !pi*(rout^2-rin^2)
     FOR ii = 0, nb-1 DO BEGIN 
        fbprof0[ptt0:ptt1,ii]   = total(anarea*sbprof0[ptt0:ptt1,ii],/cumulative)
        efbproft0[ptt0:ptt1,ii] = sqrt(total((anarea*esbproft0[ptt0:ptt1,ii])^2,/cumulative))
        IF ii EQ ih THEN BEGIN 
           efbprofc0[ptt0:ptt1] = sqrt(total((anarea*esbprofc0[ptt0:ptt1,ii])^2,/cumulative))
           efbprofs0[ptt0:ptt1] = sqrt(total((anarea*esbprofs0[ptt0:ptt1,ii])^2,/cumulative))
        ENDIF 
     ENDFOR 
  ENDFOR  
  ;
  ; now convert fluxes to magnitudes / log
  sn  = fbprof0 / efbproft0
  snc = fbprof0[*,ih]/efbprofc0[ih]
  sns = fbprof0[*,ih]/efbprofs0[ih]
  FOR ii = 0, nb-1 DO BEGIN 
     kg       = where(sn[*,ii] GE snlimit, nkg)
     kb       = where(sn[*,ii] LT snlimit, nkb)
     ;
     ; set the magnitudes and total errors for the elements above the s/n limit
     IF nkg GT 0 THEN BEGIN 
        IF ii NE ih THEN BEGIN 
           fmprof0[kg,ii]   = mag0[ii] - 2.5*alog10(fbprof0[kg,ii]/phfl[ii])
           efmproft0[kg,ii] = 2.5*alog10(1.0 + 1.0/sn[kg,ii])
        ENDIF ELSE BEGIN 
           fmprof0[kg,ii]   = alog10(fbprof0[kg,ii])
           efmproft0[kg,ii] = alog10(1.0 + 1.0/sn[kg,ii])
        ENDELSE 
     ENDIF
     ;
     ; set the magnitudes and total errors for the elements below the s/n limit
     IF nkb GT 0 THEN BEGIN 
        IF ii NE ih THEN BEGIN
           fmprof0[kb,ii]   = mflag
           efmproft0[kb,ii] = emflag
        ENDIF ELSE BEGIN 
           fmprof0[kb,ii]   = lflag
           efmproft0[kb,ii] = elflag
        ENDELSE 
     ENDIF
     IF ii EQ ih THEN BEGIN 
        ;
        ; set the continuum subtraction and sky errors for the 
        ; Halpha observations
        kg  = where(snc GE snlimit, nkg)
        kb  = where(snc LT snlimit, nkb)
        IF nkg GT 0 THEN efmprofc0[kg] = alog10(1.0 + 1.0/snc[kg])
        IF nkb GT 0 THEN efmprofc0[kb] = emflag
        kg  = where(sns GE snlimit, nkg)
        kb  = where(sns LT snlimit, nkb)
        IF nkg GT 0 THEN efmprofs0[kg] = alog10(1.0 + 1.0/sns[kg])
        IF nkb GT 0 THEN efmprofs0[kb] = emflag
     ENDIF 
  ENDFOR
  ;
  ; calculate dust corrected integrated colours
  ssoup_cp_ccolours, ll, bname, mag0, phfl, fmprof0, efmproft0, fmcfn0, efmcfn0, fmcnr0, efmcnr0, flewr0, eflewr0, flewf0, eflewf0
  ;
  ; now work on calibrate enclosed flux/ color proffiles
  openw, lu, ffcalprof0, /get_lun
  plog,ll,prog,'writing dust corrected aperture fluxes and colors '+ffcalprof0
  printf,-1,hlinef3
  printf,-1,hlinef2
  printf,lu,hlinef3
  printf,lu,hlinef2
  ;
  ; write rest of output file
  FOR jj = 0, ngal-1 DO BEGIN 
     ptt0     = pt0[jj]    ; this saves me some typing
     ptt1     = pt1[jj]    ; this saves me some typing
     IF ngal GT 0 THEN BEGIN 
        printf,-1,'# galaxy index #'+numstr(jj+1)
        printf,lu,'# galaxy index #'+numstr(jj+1)
     ENDIF 
     FOR ii = pt0[jj], pt0[jj]+kfsnlimg0[jj] DO BEGIN 
        printf,-1,rad[ii],fmprof0[ii,0],efmproft0[ii,0],fmprof0[ii,1],efmproft0[ii,1],$
               emfprofc0[ii],emfprofs0[ii],fmprof0[ii,2],efmproft0[ii,2],fmprof0[ii,3],$
               efmproft0[ii,3],fmcfn0[ii],efmcfn0[ii],fmcnr0[ii],efmcnr0[ii],$
               flewr0[ii],eflewr0[ii],flewf0[ii],eflewf0[ii],format=fmto
        printf,lu,rad[ii],fmprof0[ii,0],efmproft0[ii,0],fmprof0[ii,1],efmproft0[ii,1],$
               emfprofc0[ii],emfprofs0[ii],fmprof0[ii,2],efmproft0[ii,2],fmprof0[ii,3],$
               efmproft0[ii,3],fmcfn0[ii],efmcfn0[ii],fmcnr0[ii],efmcnr0[ii],$
               flewr0[ii],eflewr0[ii],flewf0[ii],eflewf0[ii],format=fmto
     ENDFOR 
  ENDFOR 
  free_lun, lu
END 
;
; old version of calculating colours
;  ; calculate colors and errors
;  plog,ll,prog,'calculating colors and errors'
;  smcfn    = make_array(nrtot,nb)    ; surface color mag units FUV-NUV
;  smcnr    = make_array(nrtot,nb)    ; surface color mag units NUV-R
;  slewr    = make_array(nrtot,nb)    ; surface log(EW(Halpha))
;  slewf    = make_array(nrtot,nb)    ; surface log(F_Halpha/f_FUV)
;  esmcfnt  = make_array(nrtot,nb)    ; total error in surface color FUV-NUV
;  esmcnrt  = make_array(nrtot,nb)    ; total error in surface color NUV-R
;  eslewrt  = make_array(nrtot,nb)    ; total error in surface log(EW(Halpha))
;  eslewft  = make_array(nrtot,nb)    ; total error in surface log(F_Halpha/f_FUV)
;  fmcfn    = make_array(nrtot,nb)    ; enclosed color mag units FUV-NUV
;  fmcnr    = make_array(nrtot,nb)    ; enclosed color mag units NUV-R
;  flewr    = make_array(nrtot,nb)    ; enclosed log(EW(Halpha))
;  flewf    = make_array(nrtot,nb)    ; enclosed log(F_Halpha/f_NUV)
;  efmcfnt  = make_array(nrtot,nb)    ; total error in enclosed color FUV-NUV
;  efmcnrt  = make_array(nrtot,nb)    ; total error in enclosed color NUV-R
;  eflewrt  = make_array(nrtot,nb)    ; total error in surface log(EW(Halpha))
;  eflewft  = make_array(nrtot,nb)    ; total error in surface log(F_Halpha/f_FUV)
;  ;
;  ; fuv-nuv
;  kg       = where(esmproft[*,pb3] NE emflag AND esmproft[*,pb2] NE emflag, nkg)
;  kb       = where(esmproft[*,pb3] EQ emflag OR esmproft[*,pb2] EQ emflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     smcfn[kg]   = smprof[kg,pb3] - smprof[kg,pb2]
;     esmcfnt[kg] = sqrt(esmproft[kg,pb3]^2 + esmproft[kg,pb2]^2)
;  ENDIF 
;  IF nkb GT 0 THEN BEGIN 
;     smcfn[kb]   = mflag
;     esmcfnt[kb] = emflag
;  ENDIF 
;  kg       = where(efmproft[*,pb3] NE emflag AND efmproft[*,pb2] NE emflag, nkg)
;  kb       = where(efmproft[*,pb3] EQ emflag OR efmproft[*,pb2] EQ emflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     fmcfn[kg]   = fmprof[kg,pb3] - fmprof[kg,pb2]
;     efmcfnt[kg] = sqrt(efmproft[kg,pb3]^2 + efmproft[kg,pb2]^2)
;  ENDIF 
;  IF nkb GT 0 THEN BEGIN 
;     smcfn[kb]   = mflag
;     esmcfnt[kb] = emflag
;  ENDIF 
;  ;
;  ; nuv-r
;  kg       = where(esmproft[*,pb2] NE emflag AND esmproft[*,pb0] NE emflag, nkg)
;  kb       = where(esmproft[*,pb2] EQ emflag OR esmproft[*,pb0] EQ emflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     smcnr[kg]   = smprof[kg,pb2] - smprof[kg,pb0]
;     esmcnrt[kg] = sqrt(esmproft[kg,pb2]^2 + esmproft[kg,pb0]^2)
;  ENDIF 
;  IF nkb GT 0 THEN BEGIN 
;     smcnr[kb]   = mflag
;     esmcnrt[kb] = emflag
;  ENDIF 
;  kg       = where(efmproft[*,pb2] NE emflag AND efmproft[*,pb0] NE emflag, nkg)
;  kb       = where(efmproft[*,pb2] EQ emflag OR efmproft[*,pb0] EQ emflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     fmcnr[kg]   = fmprof[kg,pb2] - fmprof[kg,pb0]
;     efmcnrt[kg] = sqrt(efmproft[kg,pb2]^2 + efmproft[kg,pb0]^2)
;  ENDIF 
;  IF nkb GT 0 THEN BEGIN 
;     fmcnr[kb]   = mflag
;     efmcnrt[kb] = emflag
;  ENDIF 
;  ;
;  ; EW(Halpha)
;  kg       = where(esmproft[*,pb0] NE emflag AND esmproft[*,pb1] NE elflag, nkg)
;  kb       = where(esmproft[*,pb0] EQ emflag OR esmproft[*,pb1] EQ elflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     slewr[kg]   = alog10(sbprof[kg,pb1]/sbprof[kg,pb0])
;     eslewrt[kg] = sqrt(esmproft[kg,pb1]^2+(0.4*esmproft[kg,pb0])^2)
;  ENDIF
;  IF nkb GT 0 THEN BEGIN 
;     slewf[kb]   = lflag
;     eslewft[kb] = elflag
;  ENDIF 
;  kg       = where(efmproft[*,pb0] NE emflag AND efmproft[*,pb1] NE elflag, nkg)
;  kb       = where(efmproft[*,pb0] EQ emflag OR efmproft[*,pb1] EQ elflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     flewr[kg]   = alog10(fbprof[kg,pb1]/fbprof[kg,pb0])
;     eflewrt[kg] = sqrt(efmproft[kg,pb1]^2+(0.4*efmproft[kg,pb0])^2)
;  ENDIF
;  IF nkb GT 0 THEN BEGIN 
;     flewf[kb]   = lflag
;     eflewft[kb] = elflag
;  ENDIF 
;  ;
;  ; Halpha/FUV
;  kg       = where(esmproft[*,pb3] NE emflag AND esmproft[*,pb1] NE elflag, nkg)
;  kb       = where(esmproft[*,pb3] EQ emflag OR esmproft[*,pb1] EQ elflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     slewf[kg]   = alog10(sbprof[kg,pb1]/sbprof[kg,pb3])
;     eslewft[kg] = sqrt(esmproft[kg,pb1]^2+(0.4*esmproft[kg,pb3])^2)
;  ENDIF
;  IF nkb GT 0 THEN BEGIN 
;     slewf[kb]   = lflag
;     eslewft[kb] = elflag
;  ENDIF 
;  kg       = where(efmproft[*,pb3] NE emflag AND efmproft[*,pb1] NE elflag, nkg)
;  kb       = where(efmproft[*,pb3] EQ emflag OR efmproft[*,pb1] EQ elflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     flewf[kg]   = alog10(fbprof[kg,pb1]/fbprof[kg,pb3])
;     eflewft[kg] = sqrt(efmproft[kg,pb1]^2+(0.4*efmproft[kg,pb3])^2)
;  ENDIF
;  IF nkb GT 0 THEN BEGIN 
;     flewf[kb]   = lflag
;     eflewft[kb] = elflag
;  ENDIF 
;
;  smcfn0    = make_array(nrtot)      ; surface color mag units FUV-NUV, corrected for internal dust
;  smcnr0    = make_array(nrtot)      ; surface color mag units NUV-R, corrected for internal dust
;  slewr0    = make_array(nrtot)      ; surface log(EW(Halpha)), corrected for internal dust
;  slewf0    = make_array(nrtot)      ; surface log(F_Halpha/f_FUV), corrected for internal dust
;  fmcfn0    = make_array(nrtot)      ; enclosed color mag units FUV-NUV, corrected for internal dust
;  fmcnr0    = make_array(nrtot)      ; enclosed color mag units NUV-R, corrected for internal dust
;  flewr0    = make_array(nrtot)      ; enclosed log(EW(Halpha)), corrected for internal dust
;  flewf0    = make_array(nrtot)      ; enclosed log(F_Halpha/f_NUV), corrected for internal dust
;  esbprofs0 = make_array(nrtot)
;  esbprofc0 = make_array(nrtot)
;  efbprofs0 = make_array(nrtot)
;  efbprofc0 = make_array(nrtot)
;  esmprofs0 = make_array(nrtot)
;  esmprofc0 = make_array(nrtot)
;  efmprofs0 = make_array(nrtot)
;  efmprofc0 = make_array(nrtot)
;  esmcfn0   = make_array(nrtot) 
;  esmcnr0   = make_array(nrtot) 
;  eslewr0   = make_array(nrtot) 
;  eslewf0   = make_array(nrtot) 
;  efmcfn0   = make_array(nrtot) 
;  efmcnr0   = make_array(nrtot) 
;  eflewr0   = make_array(nrtot) 
;  eflewf0   = make_array(nrtot) 
;  ;
;  ; calculate dust corrected surface colors and EWs
;  ; fuv-nuv
;  kg        = where(smprof0[*,p3] NE mflag AND smprof0[*,p2] NE mflag, nkg)
;  kb        = where(smprof0[*,p3] EQ mflag OR smprof0[*,p2] EQ mflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     smcfn0[kg]  = mag0[p3]-mag0[p2]-2.5*alog10((phfl[p2]*sbprof0[kg,p3])/(phfl[p3]*sbprof0[kg,p2]))
;     esmcfn0[kg] = sqrt(esmproft0[kg,p3]^2 + esmproft0[kg,p2]^2)
;  ENDIF
;  IF nkb GT 0 THEN BEGIN 
;     smcfn0[kb]  = mflag
;     esmcfn0[kb] = emflag
;  ENDIF 
;  ; nuv-r
;  kg        = where(smprof0[*,p2] NE mflag AND smprof0[*,p0] NE mflag, nkg)
;  kb        = where(smprof0[*,p2] EQ mflag OR smprof0[*,p0] EQ mflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     smcnr0[kg]  = mag0[p2]-mag0[p0]-2.5*alog10((phfl[p0]*sbprof0[kg,p2])/(phfl[p2]*sbprof0[kg,p0]))
;     esmcnr0[kg] = sqrt(esmproft0[kg,p0]^2 + esmproft0[kg,p0]^2)
;  ENDIF
;  IF nkb GT 0 THEN BEGIN 
;     smcnr0[kb]  = mflag
;     esmcnr0[kb] = emflag
;  ENDIF 
;  ; Halpha/R
;  kg        = where(smprof0[*,p1] NE lflag AND smprof0[*,p0] NE mflag, nkg)
;  kb        = where(smprof0[*,p1] EQ lflag OR smprof0[*,p0] EQ mflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     slewr0[kg]  = alog10(sbprof0[kg,p1]/sbprof0[kg,p0])
;     eslewr0[kg] = sqrt((0.4*esmproft0[kg,p0])^2 + esmproft0[kg,p1]^2)
;  ENDIF
;  IF nkb GT 0 THEN BEGIN 
;     slewr0[kb]  = lflag
;     eslewr0[kb] = elflag
;  ENDIF 
;  ; Halpha/FUV
;  kg        = where(smprof0[*,p1] NE lflag AND smprof0[*,p3] NE mflag, nkg)
;  kb        = where(smprof0[*,p1] EQ lflag OR smprof0[*,p3] EQ mflag, nkb)
;  IF nkg GT 0 THEN BEGIN 
;     slewf0[kg]  = alog10(sbprof0[kg,p1]/sbprof0[kg,p3])
;     eslewf0[kg] = sqrt((0.4*esmproft0[kg,p3])^2 + esmproft0[kg,p1]^2)
;  ENDIF
;  IF nkb GT 0 THEN BEGIN 
;     slewf0[kb]  = lflag
;     eslewf0[kb] = elflag
;  ENDIF 
;  esprofc0          = esprofc                                    ; same as uncorrected cont sub error 
;  esproft0          = esproft                                    ; same as uncorrected cont sub error (for now)
;  efprofc0          = efprofc                                    ; same as uncorrected cont sub error 
;  efproft0          = efproft                                    ; same as uncorrected cont sub error (for now)
;  scfn0             = sprof0[*,pb3] - sprof0[*,pb2]
;  scnr0             = sprof0[*,pb2] - sprof0[*,pb0]
;  escfn0            = sqrt(esprofs0[*,pb3]^2 + esprofs0[*,pb2]^2)
;  escnr0            = sqrt(esprofs0[*,pb2]^2 + esprofs0[*,pb0]^2)
;  fcfn0             = fprof0[*,pb3] - fprof0[*,pb2]
;  fcnr0             = fprof0[*,pb2] - fprof0[*,pb0]
;  efcfn0            = sqrt(efprofs0[*,pb3]^2 + efprofs0[*,pb2]^2)
;  efcnr0            = sqrt(efprofs0[*,pb2]^2 + efprofs0[*,pb0]^2)
;  slewr0            = alog10(sha0/sr0)
;  slewf0            = alog10(sha0/sf0)
;  eslewr0           = alog10(1.0+sqrt(esha^2+esr^2))
;  eslewf0           = alog10(1.0+sqrt(esha^2+esf^2))
;  flewr0            = alog10(fha0/fr0)
;  flewf0            = alog10(fha0/ff0)
;  eflewr0           = alog10(1.0+sqrt(efha^2+efr^2))
;  eflewf0           = alog10(1.0+sqrt(efha^2+eff^2))
